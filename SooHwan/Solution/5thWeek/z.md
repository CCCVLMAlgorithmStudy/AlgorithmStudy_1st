* 주차 : 5주차
* 문제명 : Z
* 링크 : https://www.acmicpc.net/problem/1074
* 사용언어 : C++ 
* 자체평점(5점 만점) : 2/5 
  
  ---

  풀이

  재귀호출을 사용해서 풀 수 있는 구조이다. 다만 직접 탐색을 하는 것은 불가능한데 최대 입력이 2^15*2^15 = 2^30개의 정수를 배열에 담으려면 2^32 바이트 = 4GB의 메모리가 필요하기 때문이다. 이는 메모리 제한인 128MB를 아득히 상회한다. 이를 해결하기 위해서, 주어진 점이 어느 구역에 있는 점인지를 확인해서 과정을 생략하고 찾아 들어가야 한다.  
  판의 크기를 결정하는 변수 N과 좌표 r,c를 입력으로 받는다. N의 최댓값이 15이기 때문에 결과값의 최댓값은 2^30-1, 4바이트 int값에 딱 들어가는 값이다. (다만 코드에서는 만약을 위해 unsigned int를 사용했다.) 판을 4등분해서 주어진 점이 이 4등분한 판 중 어떠한 판 위에 있는 점인지를 확인한다. 방문하는 순서대로 1,2,3,4사분면이라고 하면  

    1) 1사분면에 있는 경우 - 좌표와 탐색횟수를 보정하지 않고 그대로 판 사이즈를 하나 줄여서 같은 탐색을 계속한다.  
    
    2) 2사분면에 있는 경우 -  1사분면을 모두 탐색한 뒤 도달해야 하므로 사분면의 크기인 2^N-1*2^N-1을 더하고, c 값에서 전체 판 길이의 절반값인 2^N-1을 빼서 보정해 준 뒤 탐색을 이어간다.  

    3)3사분면에 있는 경우 - 1,2사분면을 모두 탐색한 뒤 도달해야 하므로 사분면 두 개 분의 크기를 탐색 횟수에 더해주고 이번엔 r값을 보정해준다.  
    
    4)4사분면에 있는 경우 - 1,2,3사분면을 모두 탐색한 뒤 도달해야 하므로 사분면 세 개 분의 크기를 탐색횟수에 더해주고, r,c 모두 보정해준다.

    함수 호출 횟수는 N값과 완전히 동일하다. 따라서 시간 복잡도는 O(N)이다.